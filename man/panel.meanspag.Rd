% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/panel.meanspag.r
\name{panel.meanspag}
\alias{panel.meanspag}
\title{Lattice panel function for spagghetti plots with a mean line}
\usage{
panel.meanspag(x, y, subscripts, groups, ..., myFun = mean,
  sumText = "Mean", individual.col = gray[5], type = "l",
  average.lwd = 3, average.col = red[8], add.legend = T, legend.panel.row,
  legend.panel.column, legend.x, legend.y, show.points = F)
}
\arguments{
\item{x,y}{The regular x, y input for panel functions}

\item{subscripts}{default lattice pass-through}

\item{groups}{default lattice pass-through}

\item{myFun}{the summarization function (mean)}

\item{sumText}{text to describe the summary function ("mean")}

\item{individual.col}{= color of individual lines (spagghetti elements)}

\item{type}{like the lattice argument type for line type}

\item{average.lwd}{line width of average line}

\item{average.col}{color of average line}

\item{add.legend}{logical (T) determining if a legend should be drawn}

\item{legend.panel.row}{row number of the legend in the x by x grid of panels}

\item{legend.panel.column}{column number of the legend in the x by x grid of panels}

\item{legend.x}{x coordinate within the panel}

\item{legend.y}{y coordinate within the panel}

\item{show.points}{logical indicating to show observed data dots}
}
\value{
Lattice panel output (invisible)
}
\description{
Lattice panel function for spagghetti plots with a mean line
}
\examples{
xyplot(value ~ time | dose *  type
       , data = pkpdData
       , subset = dose > 0 & value > 0
       , groups = id
       , aspect = 1
       , panel = panel.meanspag
)

out = get.xpose.tables(file.path(getOption("qpExampleDir"),"example2"))
trellis.strip.color()
xyplot(CONC ~ TIME
       , data = out
       , groups = ID
       , subset = EVID==0
       , aspect = 1
       , scales = list(x = list(relation = "free"), y = list(log = 10))
       , panel = panel.meanspag
       , yscale.components = yscale.components.log10.3
)

# in case there are too many times to average by then the following might be #'#better interpretable
ptimes = seq(min(out$TIME),max(out$TIME), length = 14)
xyplot(CONC ~ Cbind(TIME, metrumrg::snap(TIME, rule = ptimes))
      , data = out
      , groups = ID
      , subset = EVID==0
      , aspect = 1
      , scales = list(x = list(relation = "free"), y = list(log = 10))
      , panel = function(x,y,...)
      {
        panel.xyplot(x,y,..., col = gray[5], type = 'l')
        yy = tapply(y, attr(x, "other")[,1], mean)
        llines(as.numeric(names(yy)), yy, col = red[8], lwd = 2)
     }
      , yscale.components = yscale.components.log10.3
)
}

