% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot.fit.r
\name{plot.fit}
\alias{plot.fit}
\title{Plotting function for nls.predict and nlme.predict}
\usage{
\method{plot}{fit}(
  x,
  ...,
  newFunc,
  yLabel,
  xLabel,
  label.cex = 1.25,
  xLimits,
  yLimits,
  title,
  plot.title = TRUE,
  layout,
  aspect,
  mnplot = TRUE,
  seplot = TRUE,
  logX = FALSE,
  logY = FALSE,
  pointcol = gray[8],
  linecol = qp.blue,
  axis.lim.widener = 0.035,
  do.plot = TRUE,
  abline = NULL
)
}
\arguments{
\item{x}{the output from \code{nls.predict} or \code{nlme.predict}, i.e. class \code{'fit'}}

\item{...}{any other arguments to be passed on to the lattice call}

\item{newFunc}{the function to plot. If not suppliued will be taken from \code{x}}

\item{yLabel}{same as \code{ylab}}

\item{xLabel}{same as \code{xlab}}

\item{label.cex}{fontmszie of axes labels}

\item{xLimits}{same as \code{xlim}}

\item{yLimits}{same as \code{ylim}}

\item{title}{place a title above}

\item{plot.title}{logical indicating if a plot title should be written}

\item{layout}{will be passed on a lattice argument \code{layout}}

\item{aspect}{lattice banking aspect}

\item{mnplot}{logical indicating an average plot to be created as opposed to 'raw data}

\item{seplot}{logical indicating is error bars need to be drawn}

\item{logX}{logarithmic X axis?}

\item{logY}{logarithmic Y axis?}

\item{pointcol}{color of dots}

\item{linecol}{color of}

\item{axis.lim.widener}{scalar to stretch the x and y axis. Use in case data or predictions are not visible anymore}

\item{do.plot}{Defaults to T (create the plot) if F it will output the prediction data}

\item{abline}{will be passed on to the lattice call as is}
}
\value{
A plot
}
\description{
Plots residual, predicted, or partial residial plots based on x generated by qP functions nlme.predict and nls.predict.
}
\examples{
pkpdData = example.pkpdData()

DNase1 <- subset(DNase, Run == 1)

## using a selfStart model
fm1DNase1 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
summary(fm1DNase1)

fm1DNase1.predict = nls.predict(density ~ conc,object = fm1DNase1)
plot(fm1DNase1.predict)
fm1DNase1.predict = nls.predict(density ~ conc,object = fm1DNase1)
plot(fm1DNase1.predict, logX = TRUE)

EFF.1comp.1abs <- function(dose, tob, cl, v, ka, keo)
{
  # Effect-site concentration for 1-compartment model, 1st-order absorption

  kel = cl / v

  # Define coefficients
  A = 1/(kel-ka) / (keo-ka)
  B = 1/(ka-kel) / (keo-kel)
  C = 1/(ka-keo) / (kel-keo)

  # Return effect-site concentration
  dose*ka*keo/v * (A*exp(-ka*tob) + B*exp(-kel*tob) + C*exp(-keo*tob))
}
fit.PD004.nlme = nlme.run(model = value ~ base +
 EFF.1comp.1abs(dose, time, cl * exp(cl.eta), v, ka, keo)
 , data = subset(pkpdData,type == "PD" & dose > 0 & value > 0.5),
                          fixed = base + cl + v + ka + keo ~ 1,
                          random = cl.eta ~ 1,
                          groups = ~ id,
                          start = c(base = 1, cl = 1, v = 10
                          , ka = 1, keo = 0.01),
                          problem = "True Model",
                          reference = 4)
summary(fit.PD004.nlme$object)
nlme.extract(fit.PD004.nlme$object)$table

# simple fit vs time
fit.PD004.pred.nlme = nlme.predict(func = value ~ time
   , fit.PD004.nlme$object)
plot(fit.PD004.pred.nlme)
fit.PD004.pred.nlme = nlme.predict(func = value ~ time
   , fit.PD004.nlme$object, method = "partial.residuals")
plot(fit.PD004.pred.nlme) ## this is the same: PARTIAL RESIDUALS
fit.PD004.pred.nlme = nlme.predict(func = value ~ time
   , fit.PD004.nlme$object, method = "prediction")
plot(fit.PD004.pred.nlme) ## 'simple' prediction for all xCovariate

## note that prediction and partial residual type of model fit
## plots are very different

# fit vs time by dose
fit.PD004.pred.nlme = nlme.predict(func = value ~ time | dose
   , fit.PD004.nlme$object)
plot(fit.PD004.pred.nlme)
fit.PD004.pred.nlme = nlme.predict(func = value ~ time | dose
   , fit.PD004.nlme$object, method = "residuals")
plot(fit.PD004.pred.nlme, yLimits = c(-1,1))
plot(fit.PD004.pred.nlme, yLimits = c(-1,1)
   , abline = list(h = 0, lty = 2))
}
